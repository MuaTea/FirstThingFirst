内核链表

源文件的位置：/usr/src/linux-headers-4.15.0-112/include/linux

1、链表的原型
	struct list_head {
		struct list_head *next, *prev;
	};

2、内核链表的初始化
方式1：使用宏定义初始化
	#define LIST_HEAD_INIT(name) { &(name), &(name) }

	#define LIST_HEAD(name)  struct list_head name = LIST_HEAD_INIT(name)
	LIST_HEAD(name) ==> struct list_head name = LIST_HEAD_INIT(name) ==> struct list_head name = { &(name), &(name) }

方式2：使用内联函数进行初始化
	static inline void INIT_LIST_HEAD(struct list_head *list)
	{
		//WRITE_ONCE(list->next, list);
		list->next = list;
		list->prev = list;
	}
	
3、判断空
	static inline int list_empty(const struct list_head *head)
	{
		//return READ_ONCE(head->next) == head;
		return (head->next == head);
	}

4、插入节点
static inline void __list_add(struct list_head *new,struct list_head *prev,struct list_head *next)
{
    if (!__list_add_valid(new, prev, next))
        return;

    next->prev = new;
    new->next = next;
    new->prev = prev;
    //WRITE_ONCE(prev->next, new);
	prev->next = new;
}
后插：插入到head的后面
static inline void list_add(struct list_head *new, struct list_head *head)
{
    __list_add(new, head, head->next);
}

尾插（前插）：插到head的前面
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
    __list_add(new, head->prev, head);
}

删除节点：
第一步：
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
    next->prev = prev;
    //WRITE_ONCE(prev->next, next);
	prev->next = next;
}
第二步：
static inline void __list_del_entry(struct list_head *entry)
{
    if (!__list_del_entry_valid(entry))
        return;

    __list_del(entry->prev, entry->next);
}
第三步：
static inline void list_del(struct list_head *entry)
{
    __list_del_entry(entry);
    //entry->next = LIST_POISON1;
    //entry->prev = LIST_POISON2;
	entry->next = NULL;
	entry->prev = NULL;
}

#define POISON_POINTER_DELTA 0

#define LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)
#define LIST_POISON2  ((void *) 0x200 + POISON_POINTER_DELTA)


struct test{
	int a;
	int b;
	int c;
	char d;
};
struct test t;

/* 使用内核链表定义节点 */
typedef int datatype;
typedef struct kernel_link{
        datatype data;//数据域
        struct list_head knode;//内核链表（小结构体）
}node,*pnode;


结构体起始地址 = 结构体成员地址-偏移量
计算结构体成员在当前结构体里的偏移量：
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)

根据结构体成员地址计算得到整个结构体地址，也就是根据子结构体地址得到整个大结构体地址：
#define container_of(ptr, type, member) ({          \
        const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})

#define list_entry(ptr, type, member)  container_of(ptr, type, member)


ptr:小结构体指针
type:大结构体类型
member:成员名（即小结构体变量名）

int a[4] = {1,2,3,4};
&a[3] - 2 = &a[1]
0x2008 - 2 = 0x2000

遍历链表：
for(p = list_entry(H->knode.next,node,knode);p != H;p = list_entry(p->knode.next,node,knode))//有报段错误的风险

/* 安全遍历方式 */
#define list_for_each_entry_safe(pos, n, head, member)          \
    for (pos = list_entry((head)->next, typeof(*pos), member),  \
            n = list_entry(pos->member.next, typeof(*pos), member); \
            &pos->member != (head);                 \
            pos = n, n = list_entry(n->member.next, typeof(*n), member))

pos:大结构体指针，用来遍历
n:大结构体指针，用来操作
head:&(H->knode)
member:小结构体变量名





